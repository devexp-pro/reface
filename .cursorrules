# Reface Development Guidelines

## Writing Code with Reface

### Imports

- Use module-specific imports:
  ```typescript
  import { createElement, Fragment } from "@reface/jsx";
  import type { Template } from "@reface/types";
  import { styled } from "@reface/elements";
  import { html } from "@reface/html";
  import { clean } from "@reface/layouts";
  ```

### HTML Templates

- Use `html` for trusted HTML content:

  ```typescript
  // Safe by default
  const template = html`<div>${userInput}</div>`;

  // Explicitly trust HTML
  const trusted = html`<div>${html(trustedHTML)}</div>`;
  ```

### Elements

- Use element factories for components:

  ```typescript
  import { div, span } from "@reface/elements";

  const template = div({ class: "container" })`
    ${span`Hello World`}
  `;
  ```

### Styled Components

- Use styled components for CSS-in-JS:
  ```typescript
  const Button = styled.button`
    & {
      background: blue;
      color: white;
    }
    &:hover {
      background: darkblue;
    }
  `;
  ```

### JSX

- Always use `.tsx` extension for files containing JSX
- Always import createElement and Fragment when using JSX:

  ```typescript
  import { createElement, Fragment } from "@reface/jsx";
  ```

- Use JSX for components:

  ```typescript
  // Required imports
  import { createElement, Fragment } from "@reface/jsx";
  import type { Template } from "@reface/types";

  function MyComponent({ title }: Props): Template {
    return (
      <div class="container">
        <h1>{title}</h1>
      </div>
    );
  }
  ```

- Use Fragment for multiple elements:
  ```typescript
  function List(): Template {
    return (
      <Fragment>
        <li>First item</li>
        <li>Second item</li>
      </Fragment>
    );
  }
  ```

### Preferred Syntax

- Use JSX for components by default:

  ```tsx
  // Preferred
  function Header(): Template {
    return (
      <header class="container">
        <nav>{/* ... */}</nav>
      </header>
    );
  }

  // Instead of template literals
  const Header = component(
    () => html`
      <header class="container">
        <nav>...</nav>
      </header>
    `
  );
  ```

- Use styled-components for styling:

  ```tsx
  // Preferred
  const StyledHeader = styled.header`
    & {
      padding: 1rem;
      background: white;
    }
  `;

  // Instead of inline styles
  <header style="padding: 1rem; background: white;">
  ```

## Contributing to Reface

### Project Structure

```
reface/
├── core/       # Core rendering engine
├── html/       # HTML template system
├── elements/   # Element factories
├── jsx/        # JSX support
└── layouts/    # Layout system
```

### Module Guidelines

1. Core Module

   - Keep it minimal and focused
   - Handle core rendering logic
   - Manage security features
   - File organization:
     ```
     core/
     ├── mod.ts       # Public API
     ├── types.ts     # Type definitions
     ├── render.ts    # Core rendering logic
     ├── escape.ts    # Security utilities
     └── attributes.ts # Attribute handling
     ```

2. HTML Module

   - Focus on string manipulation
   - Handle template processing
   - Manage XSS protection
   - File organization:
     ```
     html/
     ├── mod.ts       # Public API
     ├── types.ts     # Type definitions
     ├── templates.ts # Template processing
     ├── escape.ts    # HTML escaping
     └── attributes.ts # Attribute handling
     ```

3. Elements Module

   - Provide element factories
   - Handle attribute processing
   - Support styled components

4. JSX Module

   - Keep JSX runtime simple
   - Support Fragment
   - Handle children correctly

5. Layouts Module
   - Focus on page structure
   - Handle meta tags
   - Support different layouts

### Testing

- Place tests in `__tests__` directory
- Use integration tests for features
- Test security features thoroughly
- Use compareHTML for HTML comparison:

  ```typescript
  import { compareHTML } from "../../__tests__/utils.ts";

  Deno.test("Component - should render correctly", () => {
    const result = render(Component({}));
    compareHTML(
      result,
      `
      <div>Expected HTML</div>
    `
    );
  });
  ```

- Write separate tests for each case:

  ```typescript
  // Preferred
  Deno.test("styled.div - should create basic styled div", () => {
    const StyledDiv = styled.div`
      & {
        color: red;
      }
    `;

    const result = render(StyledDiv({}));
    assertEquals(result, '<div style="color: red;"></div>');
  });

  // Instead of steps
  Deno.test("styled - tag based components", async (t) => {
    await t.step("should create basic styled div", () => {
      // test code
    });
  });
  ```

- Use descriptive test names: "ComponentName - should do something specific"
- One assertion per test
- Keep tests focused and isolated

### Documentation

- Keep docs in sync with code
- Document security implications
- Provide clear examples
- Update CHANGELOG.md

### Code Style

- Use TypeScript strict mode
- Export types separately
- Use meaningful names
- Comment complex logic
- Follow existing patterns

### Security

- Always escape user input
- Mark trusted content explicitly
- Test XSS protection
- Document security features

### File Organization

- Each module follows a consistent structure:

  ```
  module/
  ├── mod.ts              # Public API exports
  ├── types.ts            # Type definitions
  ├── core-feature.ts     # Core functionality
  ├── utils/              # Helper functions
  │   ├── mod.ts         # Utils exports
  │   └── helpers.ts     # Utility functions
  └── __tests__/         # Tests
      ├── unit/          # Unit tests
      └── integration/   # Integration tests
  ```

- Module exports:

  ```typescript
  // mod.ts
  export type { ModuleTypes } from "./types.ts";
  export { mainFeature } from "./core-feature.ts";
  export { utilities } from "./utils/mod.ts";
  ```

- Test organization:

  ```typescript
  // __tests__/integration/feature.test.ts
  Deno.test("Feature - Integration", async (t) => {
    await t.step("should handle basic case", () => {
      // Test code
    });

    await t.step("should handle edge case", () => {
      // Test code
    });
  });
  ```
